<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>秋招面经总结</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="doc/linux-style.css" type="text/css" />
</head>
<body>
<div id="header">
<h1 class="title">秋招面经总结</h1>
</div>
<div id="TOC">
<ul>
<li><a href="#秋招面经总结">秋招面经总结</a><ul>
<li><a href="#沐曦集成电路--gpu用户态开发">沐曦集成电路--GPU用户态开发</a></li>
<li><a href="#元戎启行--嵌入式软件开发">元戎启行--嵌入式软件开发</a></li>
<li><a href="#腾讯--后台开发">腾讯--后台开发</a></li>
<li><a href="#泰凌微电子--嵌入式开发已oc">泰凌微电子--嵌入式开发(已OC)</a></li>
<li><a href="#同为股份--cpp开发已oc">同为股份--cpp开发(已OC)</a></li>
<li><a href="#经纬恒润--嵌入式开发已oc">经纬恒润--嵌入式开发(已OC)</a></li>
<li><a href="#小米--嵌入式软件开发">小米--嵌入式软件开发</a></li>
<li><a href="#格兰菲---audio嵌入式开发已oc">格兰菲-- Audio嵌入式开发(已OC)</a></li>
<li><a href="#景嘉微电子----linux驱动开发">景嘉微电子 -- Linux驱动开发</a></li>
<li><a href="#江波龙----嵌入式软件开发">江波龙 -- 嵌入式软件开发</a></li>
<li><a href="#地平线----芯片原型验证">地平线 -- 芯片原型验证</a></li>
<li><a href="#开立医疗--c开发">开立医疗--c++开发</a></li>
<li><a href="#字节--客户端开发">字节--客户端开发</a></li>
<li><a href="#中科曙光--c语言闪存开发已oc">中科曙光--c语言闪存开发(已oc)</a></li>
<li><a href="#摩尔线程--系统软件开发">摩尔线程--系统软件开发</a></li>
<li><a href="#新凯来--软件开发">新凯来--软件开发</a></li>
<li><a href="#小红书笔记中的总结">小红书笔记中的总结</a></li>
<li><a href="#关于麒麟实习的内容">关于麒麟实习的内容</a></li>
<li><a href="#宝洁八问">宝洁八问</a></li>
</ul></li>
</ul>
</div>
<h1 id="秋招面经总结">秋招面经总结</h1>
<h2 id="沐曦集成电路--gpu用户态开发">沐曦集成电路--GPU用户态开发</h2>
<h3 id="一面-2025.09.01">一面 2025.09.01</h3>
<ul>
<li>1 问实习经历，问碰到的困难？</li>
<li>2 网络了解哪些？</li>
<li><strong>3 rpc知道是什么吗？</strong></li>
<li>4 知道数字电路吗？</li>
<li><strong>5 qemu的概念是什么？</strong></li>
<li><strong>6 qemu虚拟机是如何通过网络传输到物理机上的？</strong></li>
<li><strong>7 freertos的概念是什么？</strong></li>
<li><strong>8 实时性你是怎么理解的？</strong></li>
<li><strong>9 linux为什么不是实时操作系统？</strong></li>
<li>10 进程与线程的区别？</li>
<li>11 进程的原理是什么？</li>
<li>12 知道内存泄露吗？</li>
<li>13 一个进程内存泄露后，进程结束了，还会内存泄露吗？</li>
<li>14 父进程一定会对子进程进行回收吗？</li>
<li>15 若该进程的父进程没有进行回收(waitpid)，这个进程会干啥？</li>
<li>16 若这个进程的父进程先于子进程结束，会干啥？</li>
<li>17 堆和栈的区别？</li>
<li>18 栈里面存储了哪些内容？</li>
<li><strong>19 如果一个数组a a[0]和a[1]哪个在高地址？ 在堆中哪个在高地址？</strong></li>
<li>20 用过哪些锁？</li>
<li>21 互斥锁怎么实现？</li>
<li>22 互斥量是怎么实现的？</li>
<li><strong>23 原子操作知道哪些？</strong></li>
<li>24 struct和class的区别有哪些？</li>
<li>26 struct中可以有成员函数吗？</li>
<li>26 虚函数是什么？</li>
<li>27 虚函数表是全局有一张，还是每个对象有一张？</li>
<li>28 智能指针知道哪些？</li>
<li><strong>29 如何实现共享指针，共享指针的底层原理？</strong></li>
<li><strong>30 lamda表达式参数捕获？</strong></li>
<li><strong>手撕：字符串相减</strong></li>
</ul>
<h3 id="二面-2025.09.16">二面 2025.09.16</h3>
<ul>
<li>1 有看过除了nfs其他的内容吗？</li>
<li>2 驱动一个字符设备的流程</li>
<li><strong>3 fileoperation中的open用户态调用到系统调用的原理？</strong></li>
<li>4 了解过内存管理吗？</li>
<li>5 你这个芯片用的时什么架构？多少位？</li>
<li>6 那你知道这个芯片的内存分页管理吗？</li>
<li>7 假如分配10个物理页，按照你这个分页管理请问需要多大内存存储？</li>
<li><strong>8 假如程序malloc的内存，是分配的虚拟地址还是物理地址？</strong></li>
<li><strong>9 什么情况下会分配到物理地址？</strong></li>
<li>10 知道哪些系统调用？</li>
<li>11 堆和栈的区别？</li>
<li>12 什么情况下会分配栈？</li>
<li>13 一个变量在函数中用static修饰，存放在哪里？</li>
<li>14 static关键字的作用？</li>
<li>15 在c++中，一个类中的static变量，有多个方法去修改这个static变量，怎么保证数据安全？</li>
<li>16 知道哪些锁？</li>
<li>17 互斥锁和自旋锁的区别？</li>
<li><strong>18 任务就绪态是怎么实现的？</strong></li>
<li><strong>19 任务上下文需要保存哪些？</strong></li>
<li>20 c++11的特性知道哪些？</li>
<li>21 lamda表达式的参数捕获有哪几种？</li>
<li><strong>22 vitural什么时候用于一个类里面的修饰析构函数？</strong></li>
<li><strong>23 假如程序崩了你怎么调试？</strong></li>
<li><strong>手撕：有障碍的网格最小路径</strong></li>
</ul>
<h3 id="沐曦集成电路面经总结">沐曦集成电路面经总结</h3>
<ul>
<li><strong>1 原子操作</strong></li>
<li>原子读写：汇编<code>mov</code> c语言接口<code>atomic_load</code> <code>atomic_store</code></li>
<li>原子加减：汇编<code>lock add</code> c语言接口<code>atomic_fetch_add</code> <code>atomic_fetch_sub</code></li>
<li>原子交换：汇编<code>lock xchg</code> c语言接口<code>atomic_exchange</code></li>
<li>原子比较并交换：汇编<code>lock cmpxchg</code> c语言接口<code>atomic_compare_exchange_strong</code> <code>atomic_compare_exchange_weak</code></li>
<li>原子位操作：汇编<code>lock bts</code> c语言接口<code>atomic_fetch_or</code> <code>atomic_fetch_and</code> <code>atomic_fetch_xor</code> <code>atomic_fetch_nand</code></li>
<li><strong>2 互斥量底层原理</strong></li>
</ul>
<p>互斥量的底层原理是：mutex的本质就是一个内存标志，这个标志可以是一个flag，也可以是一个指针，指向一个持有者的线程ID。 当这个flag被标记成被占用的时候，或者持有者指针不为空的时候，那么它就不能被被别的任务（线程）访问。只有等到这个mutex变得空闲的时候，操作系统会把等待队列里的第一任务（线程）取出来，然后调度执行，如果当前CPU很忙，那么就把取出的这个任务（线程）标记为就绪（READY）状态，后续如果CPU空闲了，就会被调度。 - <strong>3 信号量的底层原理</strong></p>
<p>信号量机制由三个环节组成，等待、互斥、唤醒 基于计数器+等待队列 计数器：一个整数，用于表示可用资源的数量 等待队列（wait queue）：一个链表结构，用于存储因资源不足而阻塞的线程 信号量的核心操作是 P（也称为 wait，等待资源）和 V（也称为 signal，释放资源），两者均需保证原子性</p>
<ul>
<li><strong>4 中断的原理</strong></li>
</ul>
<p>cpu中有个寄存器是IF位，<code>cli</code>表示清除IF位，即关中断 <code>sti</code>表示设置IF位，即打开中断</p>
<ul>
<li><strong>5 智能指针哪些。底层原理</strong> 1 unique_ptr：独占所管理的资源，同一时间只能有一个unique_ptr指向该资源，不允许拷贝 2 许多个shared_ptr共享同一资源的所有权，当最后一个shared_ptr销毁时，资源才会被释放 3 weak_ptr：weak_ptr不控制资源，只能通过shared_ptr获取资源，weak_ptr不能拷贝</li>
</ul>
<p>底层原理： 其实本质上实现share_ptr就是实现一个类 shared_ptr 的核心设计是通过引用计数追踪共享对象的所有者数量，关键逻辑如下：</p>
<ul>
<li>1 每个被 shared_ptr 管理的对象，都会关联一个控制块（Control Block），其中存储： 引用计数（use_count）：记录当前有多少个 shared_ptr 指向该对象。 对象指针：指向被管理的对象（或资源）。 删除器（Deleter）：自定义的资源释放逻辑（默认用 delete）。 分配器（Allocator）：用于控制块的内存分配（可选）。</li>
<li>2 当 shared_ptr 被创建（如从原始指针构造）时，会初始化控制块，引用计数设为 1。</li>
<li>3 当 shared_ptr 被拷贝（如赋值给另一个 shared_ptr）时，共享同一个控制块，引用计数加 1（原子操作）。</li>
<li>4 当 shared_ptr 被销毁（如离开作用域）或重置（如调用 reset()）时，引用计数减 1。</li>
<li><p>5 当引用计数减至 0 时，控制块会调用删除器释放对象内存，并销毁控制块本身。</p></li>
<li><p><strong>6 lamda表达式</strong> lambda表达式是匿名函数，匿名函数的实现原理是编译器生成一个函数对象，然后调用这个函数对象。 lamda表达式的捕获参数列表有两种形式： 值捕获= 引用捕获&amp;</p></li>
<li><p><strong>7 fileoperation中的open用户态调用到系统调用的原理</strong></p></li>
</ul>
<p>c语言中的open函数<strong>通过软中断 / 特殊指令触发用户态到内核态的切换</strong> , 用户态到内核态的切换是通过硬件机制实现的，目的是让 CPU 从 “用户态特权级”（x86 的 Ring 3）切换到 “内核态特权级”（Ring 0），从而允许执行内核代码,进入内核后，系统调用入口函数（如system_call）会完成以下工作，最终找到并执行sys_open（内核中处理open系统调用的核心函数）</p>
<p><strong>f_op的赋值</strong>：根据文件的类型（普通文件、设备文件、管道等），从inode-&gt;i_fop（inode 中记录的文件操作集）复制而来。例如，字符设备文件的inode-&gt;i_fop指向驱动中定义的file_operations</p>
<p><strong>本质是 “用户态库函数→系统调用→VFS 抽象→驱动具体实现” 的分层交互</strong></p>
<ul>
<li><strong>设备号、cdev、class、设备文件的作用？</strong> 设备号：是内核区分不同设备的数字标识，由主设备号高12位，次设备号低20位 cdev：struct cdev是 Linux 内核定义的字符设备核心结构体，一般用来绑定操作集，绑定到内核。 calss：类（struct class）是 Linux 设备模型中的逻辑分类结构，用于在/sys/class/目录下创建一个类目录，辅助用户态的 udev（或 mdev）服务自动创建设备文件，无需手动mknod 设备文件：设备文件是内核与用户态进行通信的管道，设备文件名一般格式为 /dev/设备名，例如 /dev/ttyS0。</li>
<li><strong>页表项的管理分几级？</strong> 页表两级管理，由页表和页目录，每个页表和页目录的描述符是4字节大小，正好对应，高 20 位：存储 “下一级页表的物理基址” 或 “最终物理页框的基址，低 12 位：存储权限控制标志（非地址信息）</li>
<li><strong>malloc分配的是物理地址还是虚拟地址？</strong> 分配的是虚拟地址，当首次访问malloc分配的虚拟地址的时候，就是发生缺页中断，就会出现分配到物理地址，使用mmap时指定MAP_POPULATE标志时候。</li>
</ul>
<h2 id="元戎启行--嵌入式软件开发">元戎启行--嵌入式软件开发</h2>
<h3 id="一面-2025.09.02">一面 2025.09.02</h3>
<ul>
<li>1 TCP和UDP的区别？</li>
<li>2 有自己实现过TCP/UDP吗？</li>
<li><strong>3 CAN通信有了解吗？</strong></li>
<li>4 RAM和ROM的区别？</li>
<li><strong>5 定义和声明对于编译器来说有什么区别？</strong></li>
<li>6 static关键字知道是什么吗？</li>
<li>7 栈和堆什么时候使用？</li>
<li>8 一个函数的变量是在堆中还是在栈中？</li>
<li><strong>9 假如类里面用static修饰的成员函数，如果到另外一个文件下，可以使用这个类的static成员函数吗？</strong></li>
<li>10 指针和引用的区别？</li>
<li>11 智能指针知道那些？</li>
<li>12 share_ptr和unique_ptr的区别？</li>
<li>13 share_ptr底层实现是怎么样的？</li>
<li><strong>14 用过AutoSAR吗？</strong></li>
<li><strong>15 用过docker吗？</strong></li>
<li><strong>手撕 抽象shape类，继承circle，square，rectangle类，实现getarea()函数和getrectangle()函数，通过shape数组指针管理circle square rectangle类;</strong></li>
</ul>
<h3 id="元戎启行面经总结">元戎启行面经总结</h3>
<ul>
<li><p>1 <strong>声明和定义</strong> 声明：extern int x;（不分配内存，仅说明类型） 定义 int x = 5;（分配内存，生成符号）</p></li>
<li><p>2 <strong>CAN通信</strong> CAN 通信的核心是 “总线仲裁” 和 “帧传输”，流程可分为初始化、数据发送（含仲裁）、数据接收（含校验） 三个阶段。</p></li>
</ul>
<p>初始化要设置相同的波特率、工作模式（接收模式、发送模式或监听模式）</p>
<p>总线仲裁：若多个节点同时发送数据，CAN 通过 “仲裁场”（帧的 ID 部分）进行优先级判断 帧传输：仲裁获胜的节点将完整帧（含数据、校验等）发送到总线上</p>
<p>CAN 是广播式通信：发送节点不指定接收者，帧被总线上所有节点接收。</p>
<ul>
<li>3 <strong>static关键字</strong> static修饰的类成员变量属于类本身 static修饰的类成员函数属于类本身，只能访问静态成员变量 / 静态成员函数</li>
</ul>
<p>假如类里面用static修饰的成员函数，如果到另外一个文件下，可以使用这个类的static成员函数吗？ 答案是：调用的核心前提是类的声明必须可见，static成员函数的访问权限如果是privte和protected，只能在类内部和友元中访问，其他无法调用</p>
<h2 id="腾讯--后台开发">腾讯--后台开发</h2>
<h3 id="一面-2025.09.05">一面 2025.09.05</h3>
<ul>
<li>1 三道手撕：字符串解码、最大逆序对、交换数组内的区间</li>
<li>2 怎么接触到内核的？</li>
<li>3 实习中遇到的难点？</li>
<li>4 这个耗时时间是出现在哪个阶段？</li>
<li>5 除了用bpftrace调试内核你还知道哪些可以调试内核的方法？</li>
<li>6 GDB调试内核需要什么？</li>
<li>7 可以用探针知道应用层的函数调入和调出吗？</li>
<li><strong>8 hook函数你知道怎么实现吗？</strong></li>
</ul>
<h3 id="腾讯面经总结">腾讯面经总结</h3>
<ul>
<li>1 linux用户态的hook技术 假设在内核中有一个函数，我们想截断他的执行流程，比如说对某文件的读操作。这样就可以监控对这个文件的读操作。这就是钩子。 通过插入一个钩子函数，可以截断程序正常的执行流程，做自己的想做的操作，可以仅仅只做一个监控，也可以彻底截断函数的执行。</li>
</ul>
<p>khook的用法： 引入头文件<code>#include &quot;khook/engine.c</code>,在kbuild/makefile中加入，这是一个链接控制脚本，后面会具体说明这个脚本的内容, 使用khook_init()和khook_cleanup()对挂钩引擎进行初始化和注销 ```c //对于已知道原型的函数 #include <linux/fs.h> // has inode_permission() proto KHOOK(inode_permission); static int khook_inode_permission(struct inode *inode, int mask) { int ret = 0; ret = KHOOK_ORIGIN(inode_permission, inode, mask); printk(&quot;%s(%p, %08x) = %d&quot;, <strong>func</strong>, inode, mask, ret); return ret; }</p>
<p>//对于位置原型的函数 #include <linux/binfmts.h> // has no load_elf_binary() proto KHOOK_EXT(int, load_elf_binary, struct linux_binprm <em>); static int khook_load_elf_binary(struct linux_binprm </em>bprm) { int ret = 0; ret = KHOOK_ORIGIN(load_elf_binary, bprm); printk(&quot;%s(%p) = %d&quot;, <strong>func</strong>, bprm, ret); return ret; } ``` ## 岚图汽车--智能座舱开发 ### 一面 2025.09.10 - 1 说一下实习内容 - <strong>2 说一下TCP七层模型的理解？</strong> - 3 wireshark抓取到的那一层模型？ - 4 哪一层的通信协议？ - 5 你这个应用层有哪些内容？ - <strong>6 tcpdump抓取数据命令是什么？</strong> - 7 GDB如何打印堆栈？ - 8 makefile的主要内容有哪些？ - <strong>9 如何在makefile中连接动态库(.so)？</strong> - 10 有没有遇到过内存泄露，内存泄露怎么调试？ - 12 内存泄露的概念？ - 13 华为实习的数据交互是怎么实现的？ - 14 spi的通信方式？ - 15 你驱动ADS1220芯片的一个具体流程是怎么样的？ - 16 怎么理解虚函数？ - 17 代码错误你一般是怎么调试的？</p>
<h3 id="岚图汽车面经总结">岚图汽车面经总结</h3>
<ul>
<li>1 <strong>makefile中连接动态库(.so)？</strong> <code>-L&lt;path&gt;</code></li>
<li>2 <strong>内存泄露怎么查看？</strong><br />
<code>valgrind --leak-check=full --show-leak-kinds=all ./your_program  # 运行程序并检测</code></li>
</ul>
<h2 id="泰凌微电子--嵌入式开发已oc">泰凌微电子--嵌入式开发(已OC)</h2>
<h3 id="一面二面">一面&amp;二面</h3>
<ul>
<li>1 讲一下哪个接触项目是跟嵌入式有关的？</li>
<li>2 你这个项目的通信方式有哪些？</li>
<li>3 SPI和I2C总线上的差异？</li>
<li>4 如何保证电流数据的稳定性和实时性？</li>
<li>5 这个项目有没有遇到困难？</li>
<li><strong>6 如果I2C通信没有收到ACK数据，你怎么确认？</strong></li>
<li>7 华为的实现的音频设备获取是怎么实现的？</li>
<li>8 你的imx6ull项目里面的天气预报是用什么方式实现的？</li>
<li><strong>9 你了解原子操作吗？你那个操作系统的哪些用到了原子操作？</strong></li>
<li><strong>10 讲一下你这个任务的字段？</strong></li>
<li>11 内存分配你是怎么分级的？</li>
<li><strong>12 数组、链表、队列、栈、二叉树的数据区别和应用场景？</strong></li>
<li>13 枚举、结构体、联合体的区别？</li>
<li>14 请问不考虑硬件，M核可以跑Linux操作系统吗？</li>
</ul>
<h3 id="泰凌微电子面经">泰凌微电子面经</h3>
<ul>
<li>1 这个<strong>task字段</strong>有状态字段、剩余时间片，上次执行的全局时间片，优先级、进程ID,内存空间等等；</li>
<li><p>2 这个<strong>task调度</strong>是怎么实现的？当前的任务时间片ticks减少到0，调度schedule()触发切换 或者主动调用schedule()或者任务因为等待资源进入非就绪状态，调度schedule(); schedule()函数执行流程，获取cur(当前任务) 从就绪链表中查找就绪任务，优先选择时间片剩余最多的任务，若没有任务执行选择idle_task; <strong>进程上下文切换</strong>：除了中断上下文保存的寄存器之外，还需要保存CR3寄存器 <strong>中断上下文切换</strong>: cs保存当前代码段、ds数据段、ss栈段的选择子，eip中断发生时正在执行的指令地址，eflags：标志寄存器，包含中断允许位 IF</p></li>
<li><p>3 <strong>I2C 如何调试没有收到ACK数据</strong>？ 硬件层面：可以将总线连接到示波器上，软件层面：可以查看数据帧格式，同时可以用一个for循环查询从机地址是否正确？</p></li>
</ul>
<h2 id="同为股份--cpp开发已oc">同为股份--cpp开发(已OC)</h2>
<h3 id="一面">一面</h3>
<ul>
<li>1 从实习和项目中挑几个你觉得最满意的</li>
<li>2 你这些开源项目，有没有什么让你觉得眼前一亮的？</li>
<li>3 华为实习？</li>
<li><strong>4 虚函数、多态？性能开销？</strong></li>
<li>5 平时有没有代码重构过？</li>
<li><strong>6 <code>if else</code> 换成<code>switch case</code> 有没有什么更好的方法？</strong></li>
<li>7 运行代码时候有没有遇到那种预想不到的结果？</li>
<li>8 static关键字？</li>
<li>9 单例设计模式？ ### 二面</li>
<li>1华为的实习讲一下?</li>
<li>2 最大的收获是什么?</li>
<li>3你觉得实习中最难的是什么?</li>
<li>4麒麟实习讲一下?</li>
<li>5 知道多态吗?</li>
<li><strong>6 vitrual修饰的函数可以在基类的虚构函数里面调用吗?</strong></li>
<li><strong>7 会报编译错误还是运行的时候出错?</strong></li>
<li>8 抽象类知道吗?一般用于什么地方?</li>
<li>9 单例模式知道哪些?</li>
<li>10 多个线程如何保证单例模式的安全性?</li>
<li>11 STL容器知道那些?</li>
<li>12 map的底层原理?</li>
<li>13 vector的扩容机制?</li>
<li>14 c++中的内存管理?</li>
<li>15 如何保证你的代码不会内存泄漏?</li>
<li>16 平时代码出错了怎么调试代码的?</li>
<li>17 怎么发现这个指针没有malloc的?</li>
</ul>
<h2 id="经纬恒润--嵌入式开发已oc">经纬恒润--嵌入式开发(已OC)</h2>
<h3 id="一面-1">一面</h3>
<ul>
<li>1 三大特性总结一下？</li>
<li>2 子类中重写的虚函数是怎么调用到的呢？原理？</li>
<li>3 static关键字描述一下？</li>
<li>4 一个虚函数可以用static修饰吗？</li>
<li>5 指针和引用？</li>
<li>6 引用可以修改吗？</li>
<li>7 深拷贝和浅拷贝知道区别吗？</li>
<li>8 左值引用和右值引用有什么区别？</li>
<li>9 如何将左值变为右值？</li>
<li>9 malloc 和 new 的区别？</li>
<li>10 堆和栈有什么了解的吗？</li>
<li>11 内存中还有哪些数据你是了解的？</li>
<li>12 c语言的编译流程是什么？</li>
<li><strong>13 final 关键字？</strong></li>
<li>14 单例模式怎么实现？</li>
<li><strong>15 假如我一个对象赋值之后，那这样不就有两个对象吗？</strong></li>
<li>16 还了解过哪些设计模式，设计模式是为了干什么的？</li>
<li>17 讲一下华为实习实现的接口？</li>
<li>18 讲一下麒麟软件实习的内容？</li>
<li>19 GDB在某一行打断点怎么写？</li>
<li>20 你这个激光驱动器的用途是什么？</li>
<li>21 怎么保证这个温度控制在0.1摄氏度？</li>
<li>22 悬垂指针和野指针了解吗？ ### 二面</li>
<li>1 DMA用到过吗？</li>
<li>2 网络协议栈驱动过吗？</li>
<li>3 <strong>bpftrace和ftrace的区别？</strong></li>
<li>4 <strong>了解TCP/IP层的hook函数吗？</strong></li>
<li>5 用过cpp吗？刷了多少道题？</li>
<li>6 map、list、vector的使用场景？</li>
</ul>
<h3 id="经纬恒润面试总结">经纬恒润面试总结</h3>
<ul>
<li>1 <strong>单例模式</strong>：单例模式通过私有构造、禁用拷贝 / 赋值、静态访问点三大机制，确保无论如何调用，程序中始终只有一个实例，不会因赋值或拷贝产生多个对象。</li>
<li>2 <strong>虚函数</strong>： 对象创建时初始化 vptr当执行new Derived()创建子类对象时，该对象的 vptr 会被自动设置为指向Derived类的 vtable（而非Base的 vtable）。 调用时通过 vptr 找到 vtable 当执行ptr-&gt;func()时，由于ptr是基类指针且func()是虚函数，编译器不会在编译时确定调用哪个函数（这与非虚函数的 “静态绑定” 不同），而是在运行时执行以下操作： 从ptr指向的对象中取出 vptr（此时 vptr 指向Derived的 vtable）； 在Derived的 vtable 中找到func()对应的函数指针（由于子类重写了该函数，这里存放的是Derived::func()的地址）。 执行目标函数 通过找到的函数指针，最终调用Derived::func()，实现 “基类指针调用子类实现” 的效果</li>
</ul>
<h2 id="小米--嵌入式软件开发">小米--嵌入式软件开发</h2>
<h3 id="一面-2">一面</h3>
<ul>
<li><strong>1 map和unorderedmap有了解吗？</strong></li>
<li>2 这两个有什么不同的使用场景？</li>
<li>3 智能指针知道哪些？</li>
<li>4 unique_ptr是什么？</li>
<li><strong>5 shared_ptr的使用场景是什么？</strong></li>
<li>6 知道哪些锁？</li>
<li><strong>7 自旋锁有什么特点？使用场景？</strong></li>
<li>8 static const int a 修饰有什么特点？</li>
<li>9 可以用a++吗？</li>
<li>10 基类中vitural修饰的析构函数，然后通过基类指针调用子类，什么情况下会造成内存泄露？</li>
<li><strong>手撕：合并两棵树</strong></li>
</ul>
<h3 id="小米面试总结">小米面试总结</h3>
<ul>
<li>1 unorder_map是基于哈希表实现的，而map底层是红黑树，然后map是有序，unordered_map是无序</li>
<li>2 multimap 和map的区别就是，multimap 可以包含重复键。</li>
<li>3 set和map的区别就是 set是用来去重的。</li>
</ul>
<h3 id="影石--嵌入式软件开发">影石--嵌入式软件开发</h3>
<h3 id="一面-3">一面</h3>
<ul>
<li>1 讲讲你觉得最有成就感的项目？</li>
<li>2 你这个激光驱动器项目有没有具体一点的原理？</li>
<li>3 有没有遇到一些问题？</li>
<li>4 I2C总线和时序？</li>
<li><strong>5 UART的总线和时序？</strong></li>
<li>6 你这个项目为什么会耗费半年？耗时在哪里？</li>
<li>7 linux下的驱动做过吗？</li>
<li>8 字符设备开发流程？</li>
<li><strong>9 这个设备匹配的过程了解过吗？</strong></li>
<li>10 linux的进程和线程有什么区别？</li>
<li>11 进程间的通信方式知道哪些？</li>
<li>12 多个进程同时修改一个变量，怎么保证数据完整性？</li>
<li>13 虚函数和纯虚函数？</li>
<li>14 什么情况下用到虚函数？</li>
<li>15 你了解哪些设计模式？</li>
<li>16 这个华为实习中你有没有用到过虚函数？</li>
<li>17 有没有用到设计模式？</li>
<li><strong>18 了解抽象接口设计模式吗？</strong></li>
<li>19 实习的用到了单例模式吗？</li>
<li>20 你了解一个开发的完整流程吗？</li>
<li><strong>21 你知道怎么打通这个麦克风到设备的链路吗？</strong></li>
<li>22 为什么选择音频嵌入式？</li>
<li>23 采样率是什么？采样精度是什么？</li>
<li>24 一个ADC，16位，参考电压5v，精度是多少？</li>
</ul>
<h2 id="格兰菲---audio嵌入式开发已oc">格兰菲-- Audio嵌入式开发(已OC)</h2>
<h3 id="一面-4">一面</h3>
<ul>
<li>1 声明和定义？</li>
<li>2 三大特性？</li>
<li>3 多态是什么？</li>
<li>4 重载和重写的区别？</li>
<li><strong>5 如何保证类不会被继承？</strong></li>
<li>6 构造函数可以声明为虚函数吗？为什么？</li>
<li>7 static关键字?</li>
<li>8 const关键字？</li>
<li>9 指针和引用？</li>
<li>10 struct和uion的区别？</li>
<li><strong>11 对齐方式的区别？</strong></li>
<li>12 大小端的区别？</li>
<li>13 new和malloc的区别？</li>
<li>14 内存的分配情况？</li>
<li>15 任务调度的原理？</li>
<li>16 进程和线程的区别？</li>
<li>17 进程间通信方式？</li>
<li>18 进程间通信方式的优缺点是什么？</li>
<li>19 数组、链表、队列、栈、二叉树数据结构的区别？</li>
<li><strong>20 冒泡、快排、堆排序的区别？</strong></li>
<li>21 文件句柄的引用计数管理是怎么样的？</li>
<li>22 GDB如何打印堆栈？</li>
<li>23 c语言的编译流程是什么？</li>
<li>24 spi、i2c、uart的区别？</li>
<li>25 如何编写一个设备驱动开发？</li>
<li><strong>26 用户态的的open是如何调用到字符设备驱动的open的？原理是什么？</strong></li>
<li>27 用户态和内核态你怎么理解？</li>
<li><strong>28 死锁的条件？</strong></li>
<li><strong>手撕 合并两个有序链表</strong></li>
</ul>
<h3 id="二面问题大部分和一面重复重复的不再写">二面(问题大部分和一面重复,重复的不再写)</h3>
<ul>
<li><strong>1 c++中四种类型转换？</strong></li>
<li><strong>2 makefile中的$<span class="citation">@是什么意思</span>？</strong></li>
<li><strong>3 makefile中怎么寻找当前目录的所有.c文件？</strong></li>
<li>4 使用gdb需要加什么参数？</li>
<li>5 如何将驱动编译成.ko文件？</li>
<li><strong>6 字符设备驱动需要将他添加到设备树节点中，这些节点信息是什么？</strong></li>
<li><strong>7 音频ALSA驱动过吗？采样率是什么吗，通道数是什么？16位 32位这些又代表什么？</strong></li>
<li><strong>手撕 两个矩阵相乘？ -----时间复杂度太高了？是否可以优化？</strong></li>
</ul>
<h3 id="三面">三面</h3>
<ul>
<li><strong>1 c++中定义一个全局的实例对象，是怎么调用一个构造函数</strong></li>
<li><strong>2 GDB调试打印出调用栈的原理？</strong></li>
<li><strong>3 freertos的内存管理机制是怎么实现的？</strong></li>
<li><strong>4 缺页异常</strong></li>
</ul>
<h3 id="格兰非-面试总结">格兰非 面试总结</h3>
<ul>
<li><strong>1 四种类型转换：</strong> 1.static_cast&lt;&gt;，用于基本数据类型转换，2.dynamic_cast&lt;&gt;，用于多态转换，3.reinterpret_cast&lt;&gt;，用于指针转换，4.const_cast&lt;&gt;，用于常量转换</li>
<li><strong>2 Makefile中的一些考点：</strong> <code>$@</code>表示当前目标文件，<code>$&lt;</code>表示当前依赖文件，<code>$^</code>当前规则下所有依赖，<code>.PHONY</code>伪目标，<code>$*</code>模式规则中匹配的部分,<code>%</code>代表通配符，<code>-L</code> 表示链接库</li>
</ul>
<h2 id="景嘉微电子----linux驱动开发">景嘉微电子 -- Linux驱动开发</h2>
<h3 id="一面-5">一面</h3>
<ul>
<li>1 这个操作系统你做了什么改动吗？</li>
<li>2 这个有涉及到多进程吗？</li>
<li>3 内存管理分类几级？</li>
<li>4 段管理和页管理的区别？</li>
<li>5 有没有用户态到内核态之间的通信？</li>
<li>6 各个进程之间有没有链接动态库？</li>
<li>7 自旋锁和互斥锁的区别？</li>
<li>8 有没有做过3d和2d之类的驱动？</li>
<li>9 如果服务端卡死了怎么排查？</li>
<li>10 一般会怎么调试这个内核代码？ ### 二面</li>
<li>1 中断需要主要什么？</li>
<li>2 中断中你用信号量和互斥锁中的哪一个？</li>
<li>3 内存管理是怎么样的？</li>
<li>4 linux下的CFS调度器？</li>
<li>5 linux下的缺页中断你了解吗？</li>
<li>6 死锁的解决方法？</li>
<li>7 同一根总线下，I2C设备的从机地址都一样怎么办？</li>
<li>8 了解过linux下哪些模块？</li>
<li><strong>9 定义了一个int a[10] 然后a[-1] a[11]会报错吗?(这是未定义行为)</strong></li>
</ul>
<h3 id="景嘉微电子面试总结">景嘉微电子面试总结</h3>
<ul>
<li><strong>系统调用到用户态调用</strong>实现机制：用户态任务通过 “软中断”（如 x86 的int 0x80指令）触发系统调用，传入调用号和参数,保存上下文，然后进入内核态，通过系统调用号调用对应的系统调用函数，函数执行完毕，返回用户态，恢复上下文，继续执行用户态任务。</li>
<li><strong>缺页中断/异常</strong> ：当内核需要从用户态获取数据时，如果用户态数据不存在，则触发缺页中断，内核会从页表中寻找对应页，如果页不存在，则触发缺页异常，内核会从物理内存中寻找空闲页，如果物理内存中没有空闲页，则触发缺页异常，内核会从磁盘中寻找数据，如果磁盘中没有数据，则触发缺页异常，内核会从交换空间中寻找数据，如果交换空间中没有数据，则触发缺页异常，内核会从文件系统中寻找。</li>
<li>Hard Page Fault 也被称为Major Page Fault，翻译为硬缺页错误/主要缺页错误，这时物理内存中没有对应的页帧，需要CPU打开磁盘设备读取到物理内存中，再让MMU建立VA和PA的映射。</li>
<li>Soft Page Fault 也被称为Minor Page Fault，翻译为软缺页错误/次要缺页错误，这时物理内存中是存在对应页帧的，只不过可能是其他进程调入的，发出缺页异常的进程不知道而已，此时MMU只需要建立映射即可，无需从磁盘读取写入内存，一般出现在多进程共享内存区域。</li>
<li>Invalid Page Fault 翻译为无效缺页错误，比如进程访问的内存地址越界访问，又比如对空指针解引用内核就会报segment fault错误中断进程直接挂掉。</li>
</ul>
<h2 id="江波龙----嵌入式软件开发">江波龙 -- 嵌入式软件开发</h2>
<ul>
<li>1 pid算法的几个参数的作用？</li>
<li>2 linux的文件系统目录有哪些？</li>
<li>3 有没有投华为？</li>
<li>4 去的华为东莞？</li>
<li>5 qemu的操作系统有没有做自己的内容？</li>
<li>6 imx6ull有没有加入自己的内容？</li>
<li>7 usb驱动做过吗？</li>
<li>8 差分线有哪些通信？</li>
<li>9 知道linux下的文件系统结构是什么？</li>
<li>10 spi四根线？</li>
<li>11 pice驱动了解吗？</li>
</ul>
<h2 id="地平线----芯片原型验证">地平线 -- 芯片原型验证</h2>
<ul>
<li>1 内存管理了解哪些？</li>
<li>2 虚拟地址是什么？</li>
<li>3 物理地址映射到虚拟地址需要做什么？</li>
<li>4 页表你是怎么理解的？</li>
<li>5 用户态进入到内核态需要做什么？</li>
<li><strong>6 自旋锁的底层原理了解吗？</strong></li>
<li>7 多个进程同时获取自旋锁，怎么保证无法同时获取到的？</li>
<li><strong>手撕 两个矩阵相乘</strong></li>
</ul>
<h3 id="地平线面试总结">地平线面试总结</h3>
<ul>
<li><p><strong>spinlock的核心思想是基于tickets的机制</strong>： 1） 每个锁的数据结构arch_spinlock_t中维护两个字段：next和owner，只有当next和owner相等时才能获取锁； 2） 每个进程在获取锁的时候，next值会增加，当进程在释放锁的时候owner值会增加； 3） 如果有多个进程在争抢锁的时候，看起来就像是一个排队系统，FIFO ticket spinlock；</p></li>
<li><p><strong>伙伴系统算法</strong>： 伪代码实现需要体现 “按 2 的幂次方管理块”“分裂”“合并” 等核心逻辑，Linux 伙伴系统通过 “空闲块链表数组” 管理不同大小的空闲页框块，free_area 数组管理不同大小的空闲块，每个元素是双向链表，便于快速插入 / 删除。</p></li>
</ul>
<h2 id="开立医疗--c开发">开立医疗--c++开发</h2>
<ul>
<li>1 vector和list的区别？</li>
<li>2 vector的扩容机制？</li>
<li>3 vector两倍扩容的优化？</li>
<li>4 list和vector是线程安全的吗？</li>
<li>5 线程安全除了加锁，还有哪些方法？</li>
<li>6 一个进程未及时释放锁会导致什么？</li>
<li>7 如何避免死锁呢？</li>
<li>8 粘包的概念是什么，有遇到过粘包吗，如何避免粘包？</li>
<li>9 为什么确定包头和长度就可以解决粘包，有做过类似的例子吗？</li>
<li>10 TCP为什么要一次性发送几个包？</li>
<li>11 项目中有没有遇到什么比较难的问题？</li>
</ul>
<h2 id="字节--客户端开发">字节--客户端开发</h2>
<h3 id="一面-6">一面</h3>
<ul>
<li>1 拷打项目，实习，选一个你觉得最有挑战性的。</li>
<li><strong>2 UI渲染是在哪个进程里面的？</strong></li>
<li><strong>3 假如一个UI响应卡死了，你会怎么排查错误？</strong></li>
<li>4 C和C++的区别？ArkTs语言跟C++有什么区别？</li>
<li>5 C++中的类和结构体有什么区别？</li>
<li><strong>6 如果一个类和一个结构体同时存储同一种数据，内存开销一样吗？</strong></li>
<li>7 const和static的区别？</li>
<li>8 C++的封装、继承、多态？</li>
<li>9 什么情况下你会用继承？</li>
<li>10 进程和线程的区别？</li>
<li>11 进程间的通信方式？</li>
<li>12 多个进程同时读写，会发生什么？</li>
<li>13 遇到脏数据你会怎么做？</li>
<li>14 可以使用互斥锁吗？</li>
<li>15 假如读数据的case比较多，写数据的case比较少，用互斥锁还是读写锁？</li>
<li>16 并行、并发、串行的区别？</li>
<li>17 你项目里面也用到了QT，QT是用了网络请求吗？</li>
<li>18 你这个用的是TCP还是UDP？</li>
<li>19 为什么用TCP？</li>
<li>20 UDP有什么优势，应用场景？</li>
<li>21 QT的信号与槽函数？</li>
<li><strong>22 回调函数和信号与槽函数的区别？</strong></li>
<li>23 域名到网页渲染的过程？</li>
<li>24 DNS知道吗?</li>
<li><strong>25 DNS是TCP传输还是UDP传输？</strong></li>
<li>26 HTTPS知道吗？</li>
<li>27 非对称加密算法在HTTPS中有用到吗？</li>
<li>28 你还知道什么加密算法？</li>
<li><strong>29 那HTTPS中是怎么用到对称加密算法和非对称加密算法的？</strong></li>
<li>30 你说说你开发的时候怎么使用git的？</li>
<li>31 假如git合并的时候遇到冲突很多，你怎么办？</li>
<li>32 5ML和6ML去取3ML的水？</li>
<li>33 算法题：判断回文整数</li>
</ul>
<h2 id="中科曙光--c语言闪存开发已oc">中科曙光--c语言闪存开发(已oc)</h2>
<h3 id="一面-7">一面</h3>
<ul>
<li>1 手撕反转链表</li>
<li>2 进程和线程的区别？</li>
<li>3 进程间的通信方式？</li>
<li>4 知道哪些锁？</li>
<li>5 poll和epoll的区别？</li>
</ul>
<h3 id="二面">二面</h3>
<ul>
<li>1 手撕，判断你malloc的内存是否修改了？</li>
<li>2 讲解你的github代码</li>
<li>3 poll和epoll的区别？</li>
<li>4 系统调用的过程？</li>
<li>5 mmcopy源码？怎么优化mmcopy？</li>
<li>6 说几个你知道的汇编代码？</li>
<li>7 快排的原理？</li>
<li>8 一个有序数组，快排时间复杂度更高还是冒泡排序更高？</li>
</ul>
<h2 id="摩尔线程--系统软件开发">摩尔线程--系统软件开发</h2>
<h3 id="一面-8">一面</h3>
<ul>
<li>1 操作系统你做了什么，自己有没有加什么内容？</li>
<li>2 详细说一下你这个内存管理是怎么做的？</li>
<li>3 你知道linux下的内存管理是怎样吗？</li>
<li>4 和你这个比，linux下的伙伴系统算法有什么优点？</li>
<li>5 伙伴系统算法一定不会产生内存碎片吗？</li>
<li>6 进程管理是怎么做的?</li>
<li>7 知道为什么要分内核态和用户态吗？</li>
<li>8 由用户态进入内核态，一般会经历什么过程？</li>
<li>9 线程和进程有什么区别？</li>
<li>10 进程间的通信方式有哪些？</li>
<li>11 共享内存的底层实现你知道是什么吗？</li>
<li>12 线程的同步方式？</li>
<li>13 知道哪些锁，这些锁的区别是什么？</li>
<li>14 说一下C++的三大特性吧？</li>
<li>15 map和unordered_map的区别？</li>
<li>16 map和unordered_map的底层实现原理以及应用场景?</li>
<li>17 map和unordered_map时间复杂度？</li>
<li>18 栈内存大小一般多大？</li>
<li>手撕：障碍网格上下左右方向(BFS搜索)</li>
</ul>
<h3 id="二面-1">二面</h3>
<ul>
<li>手撕力扣3494：酿造药水需要的最少总时间</li>
<li>手撕力扣143：重排链表</li>
</ul>
<h2 id="新凯来--软件开发">新凯来--软件开发</h2>
<h3 id="一面-9">一面</h3>
<ul>
<li>1 讲述实习和项目</li>
<li>2 问git rebase的使用？</li>
<li>3 进程和线程的区别？</li>
<li>4 进程的通信方式？</li>
<li>5 c++的三大特性？</li>
<li>6 tcpdump可以过滤抓包范围吗，怎么指定？</li>
<li>7 手撕力扣一道没做过的简单题</li>
</ul>
<h3 id="二面-2">二面</h3>
<h2 id="小红书笔记中的总结">小红书笔记中的总结</h2>
<ul>
<li>1 DMA是什么，实现原理？</li>
<li>2 DMA和中断有什么区别？</li>
<li>3 中断上下文？</li>
<li>4 进程上下文？</li>
<li>5 有没有用过中断下半部分的工作队列和Tasklet？</li>
<li>6 在工作队列中可以休眠吗？</li>
<li>7 工作队列是在进程上下文还是在中断上下文？</li>
<li>8 介绍一下c++ 的RAII机制，自动释放内存的原理，动态管理内存的底层逻辑？</li>
</ul>
<hr />
<ul>
<li><strong>1 RAII机制</strong> RAII（Resource Acquisition Is Initialization）是 C++ 语言中的一个概念，用于管理资源。RAII 的核心思想是：在创建对象时，对象会自动获取资源，并在对象销毁时自动释放资源。</li>
<li><strong>2 DMA的实现原理</strong> DMA其实就是一个硬件，它把数据从内存拷贝到外设或者从外设拷贝到内存，DMA的实现原理是：DMA控制器会自动从内存中读取数据，并把数据写入外设，或者从外设中读取数据，并把数据写入内存。</li>
<li><p><strong>3 DMA和中断的区别</strong> ​​DMA​​ 是一种​​数据搬运技术​​，解决的是“​​如何搬​​”数据的问题，其目标是​​减轻CPU的负担 ​​中断​​ 是一种​​通信通知机制​​，解决的是“​​何时处理​​”事件的问题，其目标是​​实现异步处理和及时响应​​</p></li>
<li><p><strong>4 中断上下文</strong> 中断上下文​​是指代码在​​中断处理程序​​中执行时所处的运行环境。 EIP：中断处理程序中的指令指针 EFLags：中断处理程序中的标志寄存器 CS: 中断处理程序中的代码段选择子 DS: 中断处理程序中的数据段选择子 是由cpu硬件自动保存的。 中断处理程序保存通用寄存器的内容。</p></li>
</ul>
<p>1 不能睡眠，在中断上下文中，绝对不能调用任何可能引发睡眠或阻塞的函数​​：kmalloc(GFP_KERNEL)，mutex_lock()，msleep()， copy_from_user() 2 处理时间要短，上半部分做最紧急的任务，下半部分做其他任务。 3 中断处理程序与触发中断的进程无关。它无法直接访问用户空间的内存，也不知道当前哪个进程正在运行 4 栈空间非常有限​ - <strong>5 进程上下文</strong> 记录当前进程运行状态、以便将来能精确恢复的信息集合​​，就叫做该进程的​​上下文​​ 一般记录了： 程序计数器（PC）、 栈指针（SP）、通用寄存器 进程ID、用户ID、组ID​​、调度信息​​等等 可以睡眠，进程上下文保存了进程的运行状态，可以恢复进程运行状态</p>
<ul>
<li><strong>6 介绍一下软中断、工作队列和Tasklet</strong> 首先说一下上部分和下部分的区别，中断不能被相同类型的中断打断，而下半部依然可以被中断打断。 而有三种方法取实现下半部分：软中断、工作队列、Tasklet 软中断一般是“可延迟函数”的总称，产生后并不是马上可以执行，必须要等待内核的调度才能执行。可以理解为​​内核内部的、高优先级的待办事项列表​​，由内核自己触发和处理。</li>
</ul>
<p>tasklet也是软中断的一种，tasklet的实现利用到了软中断的机制 软中断和tasklet是运行于中断上下文的，它们属于内核态没有进程的切换，因此在执行过程中不能休眠，不能阻塞，一旦休眠或者阻塞，则系统直接挂死</p>
<p>工作队列的出现正是用在软中断和tasklet不能使用的场合，比如需要调用一个具有可延迟函数的特质，但是这个函数又有可能引起休眠、阻塞。</p>
<p>tasklet类似一种函数回调机制，由当前中断返回路径​​或​​ksoftirqd线程​​中直接执行函数</p>
<p>工作队列是内核提供的一种异步任务处理机制，它可以把任务加入一个队列，然后由一个线程去执行这些任务。</p>
<p><strong>tasklet的使用场景：</strong>1.网络驱动​​：上半部快速将数据包从硬件缓存拷贝到内存（skb），然后通过Tasklet下半部进行数据包协议处理； 2.处理磁盘I/O完成 <strong>工作队列的使用场景：</strong>1.读写慢速设备​​：如EEPROM，I2C设备，这些操作可能阻塞等待硬件响应；2.进行大量计算</p>
<ul>
<li><p><strong>7内存碎片的类型</strong> 1 外部内存碎片，堆区存在大量不连续的小空闲块。频繁分配/释放大小不一的内存，堆区就被切成零散的小块。 2 内部内存碎片，分配的内存块实际大小大于申请大小，内存分配需要字节对齐，然后申请了10字节的内容，实际申请了16字节，那么就会产生内存碎片。</p></li>
<li><strong>8 左值引用和右值引用</strong> 1 左值引用：左值引用就是对左值进行引用的类型 <code>type &amp;name = exp</code> 2 右值引用: 右值引用就是对右值进行引用的类型 <code>type &amp;&amp;name = move(exp)</code></li>
<li><strong>9 程序崩溃了怎么查看？</strong> 1.段错误，就是会访问越界了？ 2.GDB调试调用栈 3. 内存泄露：用valgrind</li>
<li><p><strong>10 一个空类占用多大的内存空间？</strong> 在 C++ 中，一个空类（没有任何成员变量和成员函数）的内存大小通常是 1 字节。</p></li>
</ul>
<h2 id="关于麒麟实习的内容">关于麒麟实习的内容</h2>
<ul>
<li>getattr函数的作用是获取文件属性，极有可能是客户端与服务器网络链路不稳定。也就是TCP/IP层，也可能是锁互斥，但偶然出现最后定的结果就是网络不稳定。</li>
<li>错误处理之后，用户态进程退出时，内核会自动遍历其文件描述符表，对所有未关闭的fd调用fput；但内核模块持有的struct file指针属于内核空间资源，模块卸载时不会被自动回收，必须由模块主动释放。若未主动释放，f_count将永久残留。</li>
<li>NLM哪些情况下会报lockd信息呢？当客户端向服务器发送 NLM 锁定请求（如LOCK、TEST、CANCEL等）后，若服务器在超时时间内未返回确认（ACK），lockd 会记录超时信息。或者服务器拒绝锁定请求。</li>
<li>lockd的超时重传时间是基础超时+指数避让超时，依赖lockd_timeout和lockd_retrans，wirte则依赖挂在选项依赖 NFS 挂载选项timeo和retrans</li>
</ul>
<h2 id="宝洁八问">宝洁八问</h2>
<ul>
<li>一定要把握STAR原则，即situation，target，action，result。</li>
</ul>
<p>1.如何看待华为？ 可能像平常我们接触到最多的就是华为的终端产品，手机、路由器这些。但因为我是通信专业的，华为也是通信起家的公司，我知道华为有很多5g基站、光交换机、海思芯片这些。华为还有自研的一些编译器、软件、像终端有自研的鸿蒙系统。然后就是这几年美国的制裁都没有让华为受到影响，华为也是越做越强，这些让我觉得华为的战略就很有远见。 华为的以客户为中心，我也是非常认同的，我接触到的很多华为的产品都是做的质量非常好的，客户体验感好了，满意了才会对我们信任。</p>
<p>华为以奋斗者为本，给每一个有技术肯努力的员工提供了好的机会和平台，这让我们在为公司奋斗是值得的，没有忧虑的，这也是华为对比其他企业的一个优点。</p>
<p>在我实习的时候，我的第一个感觉就是觉得华为从流程很快，就是有什么问题，提交请求单之后，立马会有人跟进处理，在一个就是我实习的小组氛围比较好，我感觉相处起来很舒服，和PL、导师之间会经常有交流，然后华为的晋升平台和希望也很大，另外就是华为的课外活动也很多，经常能在食堂看到一些活动，有时候还能看到一些羽毛球赛，篮球比赛这些。</p>
<p>2.职业生涯规划 我可能会先从熟悉公司的项目开始，因为自己会有C++开发、linux驱动的一些基础，再加上也在华为终端软件实习过，从自己着手一边完成公司的任务，一边提高自己的技能。争取在这个领域，比如鸿蒙开发，c++开发做到精通,三年后希望自己可以带领团队，另外一个如果自己比较适合做PL的话，也想去往PL发展。</p>
<p>3.自己的优缺点？ 优点：踏实、上进、注重细节，这是他人对我的评价。我自己也觉得性格是那种上进踏实的，在本科阶段我也是靠成绩和一些比赛获得了保研资格、然后在研究生阶段更是连续两年获得了一等奖学金。</p>
<p>缺点：对待事情太过专注而失，导致一些时候任务优先级没有分配好。就比如我会因为一个很小的失误钻研很久，但是整体项目可能没什么进展。还有就是不太善于拒绝，在团队合作过程中，我可能难以拒绝别人的请求而完成更多的任务。</p>
<p>4.你在科研项目里面扮演什么角色？ 我是主要负责人，就这个方向和领域，首先我是在一家公司实习，在那家公司里面做了一些调研，查阅了一些文献，参考了他们的可行性方案。然后根据这些方案提出了几个可行方案，具体去实现，我把底层的驱动整完后，后续分配给师弟做了一部分内容，给他做了一个上位机的实现，然后我们之间共同沟通了代码标准，制定了一个串口通信协议。</p>
<p>5.团队协作的经历？ 我有过很多团队协作，数学建模比赛、研究生课题、实习这些之类的。 数学建模比赛有做队长的经历、也有做队员的经历。主题安排是在三天时间内理解题目并且去撰写一篇论文。需要有时间上的安排，选题、确定大致的解决办法，然后分配一些题目给各个成员，我主要是做模型建立和代码编写。 研究生课题是明确我的需求，然后告诉师弟需要学那些技术，哪些功能，明确他工作内容。包括我们之间有制定过通信协议，有些时候他进度赶不上我也会适当催一催他。</p>
<p>实习的那个小组是有2个实习生的，然后每次PL给我们分配任务的时候，我们就会更具实习的内容模块，来分配，分配之后就对齐一些数据的格式，代码的合并，然后再上交这样的。期间也和其他同事交流过，我们也会经常去讨论技术方案，最后就是开发的任务也完成了，然后测试报告，方案设计也进行了验证。两个星期完成开发任务，</p>
<p>6.举例说明，你是如何制定一个很高的目标，并最终实现了它？ 我就拿我研究生做的这个课题来说吧，首先这个项目是实验室从来没有探索过的一个项目，这个从0-1的过程也是自己通过系统的调研，比如查看一些文献，查阅一些博客，然后当时是制定了一个方案，因为没有之前的经验，所以每个模块都是自己手搓实现，然后自己测试，再把每个模块整合到一起的，这也是一个非常耗时，每次遇到困难都会做测试测试到晚上，然后在对这个模块进行优化，因为我的目标是想要做到可以实际使用，跟市面上的产品媲美。所以对每个模块都会很仔细的检查，然后最后我这个项目也是成功通过了老师的验收。</p>
<p>7.实习经历中，是否发现工作中优化的部分？ 就是对于AI工具部分codemate，首先，实习的时候我并不知道这个AI工具，然后也是别人告诉我的，个人觉得可以有个实习生相关手册。</p>
<p>8.在实习中，你遇到过哪些问题？如何解决？ 在实习的时候，会遇到我都mentor很忙的时候，然后我对这个项目可能刚开始不是很熟悉，看文档看不懂，那个时候就很慌，然后这个时候mentor会给我一个任务，这个时候我可能需要先去看业务文档，拆分我自己需要的模块，然后我不懂的内容会拉着同事去熟悉业务，然后设计一个解决方案去解决这个问题。</p>
</body>
</html>
